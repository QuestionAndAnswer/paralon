#!/usr/bin/env node

import yargs = require("yargs");
import { readFileSync } from "fs";
import { promises as fsp } from 'fs'
import { join, dirname, normalize, basename } from "path";
import { getTargetService } from "./locator";
import { createMethodsMapTSDeclaration } from "./map-gen";
import { createServiceTSDeclaration } from "./service-get";
import { createServerTSDeclaration } from "./server-gen";
import { createClientTSDeclaration } from "./client-gen";
import { assembleFile, printNodes, emitFiles } from "./assembler";

const argv = yargs
    .option(
        "proto", 
        {
            alias: "s",
            type: "string",
            description: "Source .proto file path", 
            required: true
        }
    )
    .option(
        "pout",
        {
            alias: "p",
            type: "string",
            description: "Generated by pbjs .js file with messages and service definition",
            required: true
        }
    )
    .option(
        "keepts",
        { 
            alias: "k",
            type: "boolean",
            nargs: 0,
            description: "Do not remove intermediate .ts file", 
            required: false
        }
    )
    .option(
        "client",
        {
            type: "string",
            description: "Client file name. This would generate client only specific code", 
            required: false
        }
    )
    .option(
        "server",
        {
            type: "string",
            description: "Server file name. This would generate server only specific code", 
            required: false
        }
    )
    .help()
    .argv;


const protoContent = readFileSync(normalize(argv.proto)).toString();
const service = getTargetService(protoContent);
const methodsMapNode = createMethodsMapTSDeclaration(service);
const serviceNode = createServiceTSDeclaration(service);

const commonAssemblingParts = [methodsMapNode, serviceNode];

const emitPromises: Promise<unknown>[] = [];

if (argv.server) {
    const outDir = dirname(argv.server);
    const outBasename = basename(argv.server);

    const declaration = createServerTSDeclaration(service);
    const assembledDeclaration = assembleFile(argv.pout, outDir, [...commonAssemblingParts, declaration]);
    const tsString = printNodes(assembledDeclaration);
    const writePath = join(outDir, `${outBasename}.ts`);

    const p = fsp.writeFile(writePath, tsString)
        .then(() => {
            emitFiles(outDir, writePath);
            if (!argv.keepts) {
                return fsp.unlink(writePath);
            }

            return Promise.resolve();
        });
    emitPromises.push(p);
}

if (argv.client) {
    const outDir = dirname(argv.client);
    const outBasename = basename(argv.client);

    const declaration = createClientTSDeclaration(service);
    const assembledDeclaration = assembleFile(argv.pout, outDir, [...commonAssemblingParts, declaration]);
    const tsString = printNodes(assembledDeclaration);
    const writePath = join(outDir, `${outBasename}.ts`);

    const p = fsp.writeFile(writePath, tsString)
        .then(() => {
            emitFiles(outDir, writePath);
            if (!argv.keepts) {
                return fsp.unlink(writePath);
            }

            return Promise.resolve();
        });
    emitPromises.push(p);
}

Promise.all(emitPromises)
    .catch(err => {
        console.error(err);
    });
    